<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liborange</title>
  <subtitle>Seven days one Dream</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.liborange.top/"/>
  <updated>2017-07-21T16:28:29.000Z</updated>
  <id>http://blog.liborange.top/</id>
  
  <author>
    <name>Liborange</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IO知多少</title>
    <link href="http://blog.liborange.top/2017/07/21/IO-something-you-should-know/"/>
    <id>http://blog.liborange.top/2017/07/21/IO-something-you-should-know/</id>
    <published>2017-07-21T13:22:43.000Z</published>
    <updated>2017-07-21T16:28:29.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;IO 性能对于一个系统的影响是至关重要的。一个系统经过多项优化以后，瓶颈往往落在数据库；而数据库经过多种优化以后，瓶颈最终会落到 IO 。而 IO 性能的发展，明显落后于 CPU 的发展。 Memchached 也好， NoSql 也好，这些流行技术的背后都在直接或者间接地回避 IO 瓶颈，从而提高系统性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://liborange.qiniudn.com/hexo_post/ioModel.png&quot; alt=&quot;磁盘I/O 模型&quot; title=&quot;磁盘I/O 模型&quot;&gt;&lt;/p&gt;
&lt;p&gt;一次磁盘IO大约经过图中的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DMA将数据从磁盘拷贝到内核空间的缓冲区（一次拷贝）&lt;/li&gt;
&lt;li&gt;缓冲区满，通过read()函数将数据拷贝到用户空间的缓冲区（再一次拷贝），这样用户程序就可以读取到磁盘中的内容了&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="I/O 模型" scheme="http://blog.liborange.top/tags/I-O-%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>《大型网站系统与Java中间件实践》读书笔记（一）</title>
    <link href="http://blog.liborange.top/2017/07/21/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8EJava%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.liborange.top/2017/07/21/《大型网站系统与Java中间件实践》读书笔记（一）/</id>
    <published>2017-07-21T12:19:47.000Z</published>
    <updated>2017-07-21T16:28:17.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;《大型网站系统与Java中间件实践》的前两章内容总结，首先了解分布式系统的概念，其基本特性是什么样子的；然后介绍单机服务的组成与通信以及分布式系统类比单机系统时各个组件对应的内容，同时对分布式系统面临的问题做了剖析。第二章内容从服务架构、数据库架构、中间件层面对一个网站架构演化做了分析与讲解。&lt;/p&gt;
&lt;h2 id=&quot;了解分布式系统&quot;&gt;&lt;a href=&quot;#了解分布式系统&quot; class=&quot;headerlink&quot; title=&quot;了解分布式系统&quot;&gt;&lt;/a&gt;了解分布式系统&lt;/h2&gt;&lt;p&gt;《Distributed systems concepts and Design》是这样描述分布式系统的：&lt;strong&gt;A distribute system is one in which components located at networked computes communication and coordinate their actions only by messages.&lt;/strong&gt; 借此了解一下分布式系统的定义：由多个节点构成，不同节点完成不同的功能，多个节点之间通过网络通信的方式相互协作，协同完成某一个大的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://liborange.qiniudn.com/hexo_post/DistributeSystemTopology.png&quot; alt=&quot;分布式系统拓扑结构&quot; title=&quot;Optional title&quot;&gt;&lt;/p&gt;
&lt;p&gt;从分布式系统的定义中可以了解到从宏观角度看 &lt;code&gt;节点&lt;/code&gt; 和 &lt;code&gt;网络通信&lt;/code&gt; 是最核心的两个概念，下面就从这两个方面展开介绍：&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://blog.liborange.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="读书笔记" scheme="http://blog.liborange.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java中间件" scheme="http://blog.liborange.top/tags/java%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 微内核</title>
    <link href="http://blog.liborange.top/2017/07/17/Dubbo_spi_combine/"/>
    <id>http://blog.liborange.top/2017/07/17/Dubbo_spi_combine/</id>
    <published>2017-07-16T16:01:16.000Z</published>
    <updated>2017-07-21T16:12:20.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Dubbo 是一个开放的系统，有多种通讯框架（Mina/Netty/Grizzly），多种序列化协议（Hessian/JSON/PB），多种远程调用协议（DBO/RMI/WS）去支持，从(服务框架实践与探索)[]可以了解到从设计之初就设计为&lt;strong&gt;微内核+插件&lt;/strong&gt;的方式，系统或者用户有多种实现，通过插件方式选择实现，灵活度很高。&lt;/p&gt;
&lt;p&gt;微内核的实现也从Dubbo 1使用的OSGI，过渡到Dubbo2使用的SPI。SPI作为dubbo新的灵魂，从这里入手了解Dubbo，从而能更方便理解后续服务暴露，服务发现，服务治理这些功能。当然Dubbo也没有完全使用jdk SPI，而是做了更灵活的定制化实现，&lt;/p&gt;
&lt;h2 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h2&gt;&lt;p&gt;简单概括&lt;strong&gt;微内核+插件&lt;/strong&gt;的实现原理：微内核将所有&lt;code&gt;扩展点&lt;/code&gt;创建出相应的&lt;code&gt;自适应实例&lt;/code&gt;，而后根据配置在/META-INF特殊目录下配置的信息实现所有的&lt;code&gt;扩展实例&lt;/code&gt;，微内核初始化的过程就结束了。在真正使用的时候，调用自适应实例的方法时传入url，根据其中对应的参数，选择一个扩展实例作为代码真正的执行。（在看完后面的介绍之后再看这里的总结可能会理解的更清楚）其中有几个概念:扩展点(扩展类)、自适应实例、扩展实例。后续会不断出现，看多了自然就懂了。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://blog.liborange.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Dubbo" scheme="http://blog.liborange.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/"/>
    
    
      <category term="dubbo" scheme="http://blog.liborange.top/tags/dubbo/"/>
    
      <category term="spi" scheme="http://blog.liborange.top/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.liborange.top/2017/07/17/hello-world/"/>
    <id>http://blog.liborange.top/2017/07/17/hello-world/</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-07-18T09:28:10.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;第一篇，下周就有 权力的游戏 看了。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
